{"version":3,"sources":["../src/Enumer8.js"],"names":["CONFIG","Symbol","CASES","FROZEN","IDS","DEFAULTS","type","freeze","ignoreCase","iterator","Enum","config","cases","pushCase","id","val","ids","push","newCase","console","log","rawValue","typeResolve","TypeError","indexOf","Error","Object","assign","JSON","stringify","error","Case","forEach","c","keys","value","find"],"mappings":"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","sourcesContent":["import VerifyCases from './util/VerifyCases'\n\nconst CONFIG = Symbol('CONFIG'),\n\tCASES = Symbol('CASES'),\n\tFROZEN = Symbol('FROZEN'),\n\tIDS = Symbol('IDS')\n\n\n/**\n * @const {Config} Default Enum Configuration\n * @private\n */\nconst DEFAULTS = {\n\ttype: false,\n\tfreeze: false,\n\tignoreCase: false\n}\n\n/**\n * Enumeration Class\n * @class Enum\n */\nexport default class Enum {\n\t/**\n\t * Creates an instance of Enum.\n\t * @param {Config|RawTypes} [config={}]\n\t * @memberof Enum\n\t */\n\tconstructor(config = {}) {\n\t\tswitch (typeof config) {\n\t\t\tcase 'object':\n\t\t\t\tthis[CONFIG] = Object.assign(DEFAULTS, config)\n\t\t\t\tconsole.log(`config presented = ${JSON.stringify(config)}`)\n\t\t\t\tconsole.log(`configs = ${JSON.stringify(this[CONFIG])}`)\n\t\t\t\tbreak\n\n\t\t\tcase 'string':\n\t\t\t\tthis[CONFIG] = Object.assign(DEFAULTS, {type: config})\n\t\t\t\tbreak\n\n\t\t\tdefault: throw new Error('Unknown configuration recieved')\n\t\t}\n\t\t\n\t\treturn this\n\t}\n\n\t/**\n\t * Enumerates the case(s) passed into the function\n\t * @param {...caseTypes} Case A string, array of strings, or object to enumerate\n\t * @return {Enum}\n\t */\n\tcase (...Case) {\n\t\tif (this[FROZEN]) {\n\t\t\tconsole.error('Cases cannot be added after the enumeration is frozen.')\n\t\t\treturn this\n\t\t}\n\n\t\tlet {cases, type} = VerifyCases(Case)\n\n\t\tif (typeof cases !== 'object') throw new Error('UNKNOWN TYPE?')\n\n\t\tswitch (type) {\n\t\t\tcase 'array':\n\t\t\t\tcases.forEach(c => this.pushCase(c))\n\t\t\t\tbreak\n\n\t\t\tcase 'object':\n\t\t\t\tif (!this[CONFIG].type) throw new Error('Type must be configured to use enumeration cases with raw values')\n\t\t\t\tObject.keys(cases).forEach(c => this.pushCase(c, cases[c]))\n\t\t\t\tbreak\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error('UNKNOWN TYPE?')\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Returns the enumerated property with a specified value\n\t * @param {*} value The value to find in the enumeration\n\t * @returns {EnumCase}\n\t */\n\tfindVal(value) { return this.cases.find(c => c.rawValue === value) }\n\n\t/** Freezes the enumeration */\n\tfreeze() { this[FROZEN] = true }\n\n\t/**\n\t * Returns whether or not the enumeration is frozen\n\t * @returns {boolean}\n\t */\n\tisFrozen() { return this[FROZEN] }\n\n\t/**\n\t * Get all enumerated values\n\t * @return {Array}\n\t */\n\tget cases() {\n\t\tthis[CASES] = this[CASES] || {}\n\t\treturn this[CASES]\n\t}\n\n\t/** Allows for the iteration of cases */\n\t[Symbol.iterator] = () => this.cases[Symbol.iterator]()\n\n\n\t/**\n\t * Pushes enumeration to store\n\t * @param {string} id ID for the enumeration pair\n\t * @param {*} [rawValue] Optional raw value\n\t * @private\n\t */\n\tpushCase = (id, val) => {\n\t\tthis.ids.push(id)\n\t\tlet newCase = { id: id }\n\t\tconsole.log(`id: ${id}, val: ${val}, type: ${this[CONFIG].type}`)\n\t\tif (typeof val === 'undefined') newCase.rawValue = this.typeResolve(id, val, this[CONFIG].type)\n\t\telse if (typeof val !== this[CONFIG].type) throw new TypeError(`Raw value must conform to the specified type.\\nRaw value: ${typeof val}, Expected: ${this[CONFIG].type}`)\n\t\telse newCase.rawValue = val\n\n\t\tthis[id] = newCase\n\t\tthis.cases[id] = newCase\n\t}\n\n\t/**\n\t * Returns a custom rawValue if none is provided\n\t * @param {string} type The type of raw value to return\n\t * @param {string} id\n\t * @private\n\t */\n\ttypeResolve = (id, rawValue, type) => {\n\t\tswitch (typeof rawValue) {\n\t\t\tcase 'undefined':\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase false: return id\n\t\t\t\t\tcase 'string': return id\n\t\t\t\t\tcase 'number': return this.ids.indexOf(id) + 1\n\t\t\t\t\tcase 'boolean': return true\n\t\t\t\t\tdefault: throw new Error('The provided type was not found!')\n\t\t\t\t}\n\t\t\tcase this[CONFIG].type: return rawValue\n\t\t\tdefault: throw new Error(`Raw value must conform to the specified type.\\nRaw value: ${typeof rawValue}, Expected: ${this[CONFIG].type}`)\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t */\n\tget ids() {\n\t\tthis[IDS] = this[IDS] || []\n\t\treturn this[IDS]\n\t}\n\n}\n"],"file":"Enumer8.js"}